#include "quantumliquidity/market_data/oanda_feed.hpp"
#include "quantumliquidity/common/logger.hpp"
#include <nlohmann/json.hpp>
#include <sstream>
#include <chrono>

namespace quantumliquidity::market_data {

// Callback for libcurl to write data
static size_t write_callback(void* contents, size_t size, size_t nmemb, void* userp) {
    ((std::string*)userp)->append((char*)contents, size * nmemb);
    return size * nmemb;
}

// Callback for streaming data (line by line)
static size_t stream_callback(void* contents, size_t size, size_t nmemb, void* userp) {
    OANDAFeed* feed = static_cast<OANDAFeed*>(userp);
    std::string data((char*)contents, size * nmemb);
    
    // OANDA streams JSON objects separated by newlines
    // Process each line as it comes
    // Note: This is simplified - in production, handle partial lines
    
    return size * nmemb;
}

OANDAFeed::OANDAFeed(Config config)
    : config_(std::move(config))
    , connected_(false)
    , running_(false)
    , should_reconnect_(true)
    , curl_handle_(nullptr)
    , stream_handle_(nullptr)
    , ticks_received_(0)
    , reconnect_attempts_(0)
{
    // Initialize libcurl
    curl_global_init(CURL_GLOBAL_ALL);
    curl_handle_ = curl_easy_init();
    stream_handle_ = curl_easy_init();
    
    Logger::info("market_data", "OANDA feed initialized (mode: " + 
        std::string(config_.use_practice ? "practice" : "live") + ")");
}

OANDAFeed::~OANDAFeed() {
    disconnect();
    
    if (curl_handle_) {
        curl_easy_cleanup(curl_handle_);
    }
    if (stream_handle_) {
        curl_easy_cleanup(stream_handle_);
    }
    curl_global_cleanup();
}

void OANDAFeed::subscribe_ticks(const InstrumentID& instrument) {
    std::lock_guard<std::mutex> lock(mutex_);
    
    // Convert instrument format: EUR/USD -> EUR_USD (OANDA format)
    std::string oanda_instrument = convert_instrument_name(instrument);
    subscribed_instruments_.insert(instrument);
    
    Logger::info("market_data", "OANDA subscribed to: " + instrument + " (" + oanda_instrument + ")");
    
    // If already connected, restart stream with new instrument list
    if (connected_ && running_) {
        should_reconnect_ = true;
    }
}

void OANDAFeed::subscribe_bars(const InstrumentID& instrument, TimeFrame tf) {
    // OANDA doesn't stream bars, they're generated by our BarAggregator
    Logger::warning("market_data", "OANDA doesn't support bar streaming, use BarAggregator");
}

void OANDAFeed::subscribe_depth(const InstrumentID& instrument, int levels) {
    // OANDA streams don't include depth, only BBO
    Logger::warning("market_data", "OANDA streams only provide BBO (best bid/offer)");
}

void OANDAFeed::unsubscribe_ticks(const InstrumentID& instrument) {
    std::lock_guard<std::mutex> lock(mutex_);
    subscribed_instruments_.erase(instrument);
    Logger::info("market_data", "OANDA unsubscribed from: " + instrument);
    
    if (connected_ && running_) {
        should_reconnect_ = true;
    }
}

void OANDAFeed::unsubscribe_bars(const InstrumentID& instrument, TimeFrame tf) {
    // No-op
}

void OANDAFeed::unsubscribe_depth(const InstrumentID& instrument) {
    // No-op
}

void OANDAFeed::connect() {
    if (connected_) {
        Logger::warning("market_data", "OANDA feed already connected");
        return;
    }
    
    // Validate config
    if (config_.api_token.empty()) {
        std::string error = "OANDA API token is required";
        Logger::error("market_data", error);
        if (error_callback_) {
            error_callback_(error);
        }
        return;
    }
    
    if (config_.account_id.empty()) {
        std::string error = "OANDA account ID is required";
        Logger::error("market_data", error);
        if (error_callback_) {
            error_callback_(error);
        }
        return;
    }
    
    // Test connection with a simple REST call
    try {
        std::string response = http_get("/v3/accounts/" + config_.account_id);
        nlohmann::json account_info = nlohmann::json::parse(response);
        
        Logger::info("market_data", "OANDA account verified: " + config_.account_id);
        
    } catch (const std::exception& e) {
        std::string error = "Failed to connect to OANDA: " + std::string(e.what());
        Logger::error("market_data", error);
        if (error_callback_) {
            error_callback_(error);
        }
        return;
    }
    
    connected_ = true;
    running_ = true;
    
    // Start streaming thread
    streaming_thread_ = std::thread([this] { streaming_thread_func(); });
    
    Logger::info("market_data", "OANDA feed connected");
}

void OANDAFeed::disconnect() {
    if (!connected_) {
        return;
    }
    
    running_ = false;
    should_reconnect_ = false;
    
    if (streaming_thread_.joinable()) {
        streaming_thread_.join();
    }
    
    connected_ = false;
    Logger::info("market_data", "OANDA feed disconnected");
}

bool OANDAFeed::is_connected() const {
    return connected_;
}

void OANDAFeed::set_tick_callback(TickCallback callback) {
    tick_callback_ = std::move(callback);
}

void OANDAFeed::set_bar_callback(BarCallback callback) {
    bar_callback_ = std::move(callback);
}

void OANDAFeed::set_depth_callback(DepthCallback callback) {
    depth_callback_ = std::move(callback);
}

void OANDAFeed::set_error_callback(ErrorCallback callback) {
    error_callback_ = std::move(callback);
}

std::string OANDAFeed::name() const {
    return config_.feed_name;
}

std::vector<InstrumentInfo> OANDAFeed::available_instruments() const {
    // TODO: Query OANDA /v3/accounts/{accountID}/instruments
    // For now, return empty
    return {};
}

void OANDAFeed::streaming_thread_func() {
    Logger::info("market_data", "OANDA streaming thread started");
    
    while (running_) {
        try {
            reconnect_stream();
            
            // If we exit reconnect_stream and still running, wait before retry
            if (running_ && should_reconnect_) {
                int backoff = std::min(30, 1 << reconnect_attempts_);  // Exponential backoff, max 30s
                Logger::info("market_data", "OANDA reconnecting in " + std::to_string(backoff) + "s");
                std::this_thread::sleep_for(std::chrono::seconds(backoff));
                reconnect_attempts_++;
            }
            
        } catch (const std::exception& e) {
            Logger::error("market_data", "OANDA streaming error: " + std::string(e.what()));
            if (error_callback_) {
                error_callback_("Streaming error: " + std::string(e.what()));
            }
            
            if (running_) {
                std::this_thread::sleep_for(std::chrono::seconds(5));
            }
        }
    }
    
    Logger::info("market_data", "OANDA streaming thread stopped");
}

void OANDAFeed::reconnect_stream() {
    std::string instruments_param;
    {
        std::lock_guard<std::mutex> lock(mutex_);
        
        if (subscribed_instruments_.empty()) {
            Logger::warning("market_data", "No instruments subscribed, waiting...");
            std::this_thread::sleep_for(std::chrono::seconds(1));
            return;
        }
        
        // Build instruments parameter: EUR_USD,GBP_USD,USD_JPY
        for (const auto& instrument : subscribed_instruments_) {
            if (!instruments_param.empty()) {
                instruments_param += ",";
            }
            instruments_param += convert_instrument_name(instrument);
        }
    }
    
    // Stream endpoint: /v3/accounts/{accountID}/pricing/stream?instruments=EUR_USD,GBP_USD
    std::string endpoint = "/v3/accounts/" + config_.account_id + 
                          "/pricing/stream?instruments=" + instruments_param;
    
    Logger::info("market_data", "OANDA connecting to stream: " + instruments_param);
    
    // Set up streaming request
    struct curl_slist* headers = nullptr;
    headers = curl_slist_append(headers, ("Authorization: Bearer " + config_.api_token).c_str());
    headers = curl_slist_append(headers, "Content-Type: application/json");
    
    std::string url = config_.stream_url + endpoint;
    std::string response_buffer;
    
    curl_easy_setopt(stream_handle_, CURLOPT_URL, url.c_str());
    curl_easy_setopt(stream_handle_, CURLOPT_HTTPHEADER, headers);
    curl_easy_setopt(stream_handle_, CURLOPT_WRITEFUNCTION, write_callback);
    curl_easy_setopt(stream_handle_, CURLOPT_WRITEDATA, &response_buffer);
    curl_easy_setopt(stream_handle_, CURLOPT_TIMEOUT, 0L);  // No timeout for streaming
    
    // TODO: In production implementation, use stream_callback to process data in real-time
    // For now, this is a simplified version
    
    CURLcode res = curl_easy_perform(stream_handle_);
    
    curl_slist_free_all(headers);
    
    if (res != CURLE_OK) {
        throw std::runtime_error("CURL error: " + std::string(curl_easy_strerror(res)));
    }
    
    // Process received data (in real implementation, this happens in callback)
    // Split by newlines and parse each JSON object
    std::istringstream stream(response_buffer);
    std::string line;
    
    while (std::getline(stream, line) && running_) {
        if (line.empty()) continue;
        
        try {
            Tick tick = parse_pricing_stream(line);
            
            if (tick_callback_) {
                tick_callback_(tick);
            }
            
            ticks_received_++;
            reconnect_attempts_ = 0;  // Reset backoff on successful tick
            
        } catch (const std::exception& e) {
            Logger::warning("market_data", "Failed to parse OANDA tick: " + std::string(e.what()));
        }
    }
}

std::string OANDAFeed::http_get(const std::string& endpoint) {
    if (!curl_handle_) {
        throw std::runtime_error("CURL not initialized");
    }
    
    std::string url = config_.rest_url + endpoint;
    std::string response;
    
    struct curl_slist* headers = nullptr;
    headers = curl_slist_append(headers, ("Authorization: Bearer " + config_.api_token).c_str());
    headers = curl_slist_append(headers, "Content-Type: application/json");
    
    curl_easy_setopt(curl_handle_, CURLOPT_URL, url.c_str());
    curl_easy_setopt(curl_handle_, CURLOPT_HTTPHEADER, headers);
    curl_easy_setopt(curl_handle_, CURLOPT_WRITEFUNCTION, write_callback);
    curl_easy_setopt(curl_handle_, CURLOPT_WRITEDATA, &response);
    curl_easy_setopt(curl_handle_, CURLOPT_TIMEOUT, 10L);
    
    CURLcode res = curl_easy_perform(curl_handle_);
    
    curl_slist_free_all(headers);
    
    if (res != CURLE_OK) {
        throw std::runtime_error("CURL error: " + std::string(curl_easy_strerror(res)));
    }
    
    long http_code = 0;
    curl_easy_getinfo(curl_handle_, CURLINFO_RESPONSE_CODE, &http_code);
    
    if (http_code != 200) {
        throw std::runtime_error("HTTP error: " + std::to_string(http_code) + " - " + response);
    }
    
    return response;
}

Tick OANDAFeed::parse_pricing_stream(const std::string& json_line) {
    nlohmann::json j = nlohmann::json::parse(json_line);
    
    // OANDA pricing stream format:
    // {
    //   "type": "PRICE",
    //   "time": "2024-01-01T12:00:00.000000Z",
    //   "bids": [{"price": "1.10245", "liquidity": 1000000}],
    //   "asks": [{"price": "1.10250", "liquidity": 1000000}],
    //   "instrument": "EUR_USD"
    // }
    
    std::string type = j["type"];
    if (type != "PRICE") {
        // Could be HEARTBEAT or other types
        throw std::runtime_error("Not a price update");
    }
    
    Tick tick;
    
    // Parse timestamp
    std::string time_str = j["time"];
    // TODO: Proper ISO8601 parsing (use date library or similar)
    tick.timestamp = std::chrono::system_clock::now();  // Simplified for now
    
    // Parse instrument (convert EUR_USD back to EUR/USD)
    std::string oanda_instrument = j["instrument"];
    tick.instrument = oanda_instrument;
    std::replace(tick.instrument.begin(), tick.instrument.end(), '_', '/');
    
    // Parse bid/ask
    if (j.contains("bids") && !j["bids"].empty()) {
        tick.bid = std::stod(j["bids"][0]["price"].get<std::string>());
        tick.bid_size = j["bids"][0]["liquidity"];
    }
    
    if (j.contains("asks") && !j["asks"].empty()) {
        tick.ask = std::stod(j["asks"][0]["price"].get<std::string>());
        tick.ask_size = j["asks"][0]["liquidity"];
    }
    
    return tick;
}

std::string OANDAFeed::convert_instrument_name(const InstrumentID& instrument) const {
    // Convert EUR/USD -> EUR_USD (OANDA format)
    std::string result = instrument;
    std::replace(result.begin(), result.end(), '/', '_');
    return result;
}

} // namespace quantumliquidity::market_data
