#include "quantumliquidity/market_data/csv_feed.hpp"
#include "quantumliquidity/common/logger.hpp"
#include <sstream>
#include <iomanip>
#include <chrono>

namespace quantumliquidity::market_data {

CSVFeed::CSVFeed(Config config)
    : config_(std::move(config))
    , connected_(false)
    , running_(false)
    , paused_(false)
    , ticks_replayed_(0)
{
    Logger::info("market_data", "CSV feed initialized: " + config_.csv_filepath);
}

CSVFeed::~CSVFeed() {
    disconnect();
}

void CSVFeed::subscribe_ticks(const InstrumentID& instrument) {
    std::lock_guard<std::mutex> lock(mutex_);
    subscribed_instruments_.insert(instrument);
    Logger::info("market_data", "CSV feed subscribed to: " + instrument);
}

void CSVFeed::subscribe_bars(const InstrumentID& instrument, TimeFrame tf) {
    // Not implemented for CSV feed (bars are generated by aggregator)
}

void CSVFeed::subscribe_depth(const InstrumentID& instrument, int levels) {
    // Not implemented for CSV feed
}

void CSVFeed::unsubscribe_ticks(const InstrumentID& instrument) {
    std::lock_guard<std::mutex> lock(mutex_);
    subscribed_instruments_.erase(instrument);
    Logger::info("market_data", "CSV feed unsubscribed from: " + instrument);
}

void CSVFeed::unsubscribe_bars(const InstrumentID& instrument, TimeFrame tf) {
    // Not implemented
}

void CSVFeed::unsubscribe_depth(const InstrumentID& instrument) {
    // Not implemented
}

void CSVFeed::connect() {
    if (connected_) {
        Logger::warning("market_data", "CSV feed already connected");
        return;
    }

    // Open CSV file
    csv_file_.open(config_.csv_filepath);
    if (!csv_file_.is_open()) {
        std::string error = "Failed to open CSV file: " + config_.csv_filepath;
        Logger::error("market_data", error);
        if (error_callback_) {
            error_callback_(error);
        }
        return;
    }

    // Skip header line
    std::string header;
    std::getline(csv_file_, header);

    connected_ = true;
    running_ = true;

    // Start replay thread
    replay_thread_ = std::thread([this] { replay_thread_func(); });

    Logger::info("market_data", "CSV feed connected");
}

void CSVFeed::disconnect() {
    if (!connected_) {
        return;
    }

    running_ = false;

    if (replay_thread_.joinable()) {
        replay_thread_.join();
    }

    if (csv_file_.is_open()) {
        csv_file_.close();
    }

    connected_ = false;
    Logger::info("market_data", "CSV feed disconnected");
}

bool CSVFeed::is_connected() const {
    return connected_;
}

void CSVFeed::set_tick_callback(TickCallback callback) {
    tick_callback_ = std::move(callback);
}

void CSVFeed::set_bar_callback(BarCallback callback) {
    bar_callback_ = std::move(callback);
}

void CSVFeed::set_depth_callback(DepthCallback callback) {
    depth_callback_ = std::move(callback);
}

void CSVFeed::set_error_callback(ErrorCallback callback) {
    error_callback_ = std::move(callback);
}

std::string CSVFeed::name() const {
    return config_.feed_name;
}

std::vector<InstrumentInfo> CSVFeed::available_instruments() const {
    // TODO: Scan CSV file for unique instruments
    return {};
}

void CSVFeed::set_replay_speed(double multiplier) {
    config_.replay_speed = multiplier;
}

void CSVFeed::pause() {
    paused_ = true;
    Logger::info("market_data", "CSV feed paused");
}

void CSVFeed::resume() {
    paused_ = false;
    Logger::info("market_data", "CSV feed resumed");
}

bool CSVFeed::is_paused() const {
    return paused_;
}

void CSVFeed::replay_thread_func() {
    Logger::info("market_data", "CSV replay started");

    std::string line;
    Timestamp prev_timestamp;
    bool first_tick = true;

    while (running_) {
        // Handle pause
        while (paused_ && running_) {
            std::this_thread::sleep_for(std::chrono::milliseconds(100));
        }

        if (!running_) {
            break;
        }

        // Read next line
        if (!std::getline(csv_file_, line)) {
            // End of file
            if (config_.loop) {
                // Restart from beginning
                csv_file_.clear();
                csv_file_.seekg(0);
                std::string header;
                std::getline(csv_file_, header);  // Skip header
                first_tick = true;
                Logger::info("market_data", "CSV replay looping");
                continue;
            } else {
                Logger::info("market_data", "CSV replay finished");
                break;
            }
        }

        // Skip empty lines and comments
        if (line.empty() || line[0] == '#') {
            continue;
        }

        try {
            // Parse tick
            Tick tick = parse_csv_line(line);

            // Check if subscribed
            if (!is_subscribed(tick.instrument)) {
                continue;
            }

            // Calculate delay for replay speed
            if (!first_tick && config_.replay_speed > 0) {
                auto time_diff = std::chrono::duration_cast<std::chrono::milliseconds>(
                    tick.timestamp - prev_timestamp
                );

                if (time_diff.count() > 0) {
                    auto sleep_duration = std::chrono::milliseconds(
                        static_cast<int64_t>(time_diff.count() / config_.replay_speed)
                    );
                    std::this_thread::sleep_for(sleep_duration);
                }
            }

            // Invoke callback
            if (tick_callback_) {
                tick_callback_(tick);
            }

            prev_timestamp = tick.timestamp;
            last_tick_time_ = tick.timestamp;
            ticks_replayed_++;
            first_tick = false;

        } catch (const std::exception& e) {
            Logger::error("market_data", "Error parsing CSV line: " + std::string(e.what()));
            if (error_callback_) {
                error_callback_("CSV parse error: " + std::string(e.what()));
            }
        }
    }

    Logger::info("market_data",
        "CSV replay stopped. Total ticks: " + std::to_string(ticks_replayed_));
}

Tick CSVFeed::parse_csv_line(const std::string& line) {
    std::istringstream ss(line);
    std::string token;
    std::vector<std::string> fields;

    // Split by comma
    while (std::getline(ss, token, ',')) {
        fields.push_back(token);
    }

    // Validate field count
    // Expected: timestamp,instrument,bid,ask,bid_size,ask_size
    if (fields.size() < 6) {
        throw std::runtime_error("Invalid CSV format: expected at least 6 fields, got " +
            std::to_string(fields.size()));
    }

    Tick tick;

    // Parse timestamp (format: YYYY-MM-DD HH:MM:SS.mmm)
    std::tm tm = {};
    std::istringstream ts_stream(fields[0]);
    ts_stream >> std::get_time(&tm, "%Y-%m-%d %H:%M:%S");

    if (ts_stream.fail()) {
        throw std::runtime_error("Failed to parse timestamp: " + fields[0]);
    }

    auto time_point = std::chrono::system_clock::from_time_t(std::mktime(&tm));

    // Parse milliseconds if present
    size_t dot_pos = fields[0].find('.');
    if (dot_pos != std::string::npos) {
        std::string ms_str = fields[0].substr(dot_pos + 1);
        int ms = std::stoi(ms_str);
        time_point += std::chrono::milliseconds(ms);
    }

    tick.timestamp = time_point;

    // Parse other fields
    tick.instrument = fields[1];
    tick.bid = std::stod(fields[2]);
    tick.ask = std::stod(fields[3]);
    tick.bid_size = std::stod(fields[4]);
    tick.ask_size = std::stod(fields[5]);

    // Optional: last trade price and size
    if (fields.size() >= 8) {
        if (!fields[6].empty() && fields[6] != "NULL") {
            tick.last_trade_price = std::stod(fields[6]);
        }
        if (!fields[7].empty() && fields[7] != "NULL") {
            tick.last_trade_size = std::stod(fields[7]);
        }
    }

    return tick;
}

bool CSVFeed::is_subscribed(const InstrumentID& instrument) const {
    std::lock_guard<std::mutex> lock(mutex_);
    return subscribed_instruments_.empty() || subscribed_instruments_.count(instrument);
}

} // namespace quantumliquidity::market_data
